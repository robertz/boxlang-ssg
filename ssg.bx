class {

	variables.cwd = expandPath(".") & "/";
	variables.config = {
		outputDir: "_site",
		ignore: [],
		passthru: []
	};
	variables.ignoreDirs = [ cwd & "_includes/", cwd & ".", cwd & "_site/" ];
	variables.collections = { "all" : [], "tags" : [], "byTag" : {}, "global" : {} };
	variables.process = {};
	variables.baseData    = { "layouts" : {}, "views" : {} };
	variables.templates = [];

	function build(){
		getProcessConfig();

		if(variables.process.hasConfig) getSSGConfig();
		if(variables.process.hasIncludes) getIncludes();

		local.templates = [];

		fileList = directoryList(variables.cwd, true, "path", (any path) => {
			return
				((arguments.path.find(".md") || arguments.path.find(".bxm")) && !arguments.path.findNoCase("readme.md")) &&
				!ignoreDirs.find((dir) => path.find(dir));
		});

		local.templates = fileList.map((file) => {
			return {
				name: getFileFromPath(file),
				path: getDirectoryFromPath(file)
			};
		});

		local.templates.each(template => {
			processTemplate(template.path & template.name);
		});

		processCollectionsData();

		generateStatic();
	}

	function main(args = []){
		if(!args.len()) {
			printLn("No arguments provided");
			cliExit(1)
		}

		local.command = args[1];

		switch(command) {
			case "build":
				build();
				break;
			default:
				printLn("Unknown command: " & command);
				cliExit(1);
		}

		cliExit(0);
	}

	/**
	 * Build related functions
	 */

	/**
	 * Detect directory structure and setup defaul values
	 *
	 * @process the configuration object
	 */
	function getProcessConfig(){
		variables.process[ "applicationHelper" ] = fileExists( cwd & "_includes/applicationHelper.bxm" );
		variables.process[ "hasIncludes" ]       = directoryExists( cwd & "_includes" ) ? true : false;
		variables.process[ "hasData" ]           = directoryExists( cwd & "_data" ) ? true : false;
		variables.process[ "hasConfig" ]         = fileExists( cwd & "ssg-config.json" ) ? true : false;
		variables.process[ "layouts" ]           = [];
		variables.process[ "views" ]             = [];
	}

	/**
	 * Load the current build configuration from file if it exists, otherweise return defaults
	 */
	function getSSGConfig(){
		try {
			variables.config = JSONDeserialize( fileRead( cwd & "ssg-config.json", "utf-8" ) );
		} catch ( any e ) {
			printLn( "Error loading SSG config: " & e.message );
		}
	}

	/**
	 * Load layouts and views and any associated front matter
	 */
	function getIncludes(){
		// build arrays of valid layouts/views
		var fileStem = "";
		var tmp = directoryList(cwd & "_includes/layouts", false, "path", "*.bxm");
		for ( var layout in tmp ) {
			fileStem = listFirst( getFileFromPath( layout ), "." );
			process.layouts.append( fileStem );
			baseData[ "layouts" ][ fileStem ] = getTemplateData( layout );
			baseData[ "layouts" ][ fileStem ].delete( "content" );
		}
		tmp = directoryList(cwd & "_includes", false, "path", (path) => {
			return !path.findNoCase("layouts") && !path.findNoCase("applicationHelper.bxm");
		});
		for ( var view in tmp ) {
			fileStem = listFirst( getFileFromPath( view ), "." );
			process.views.append( fileStem );
			baseData[ "views" ][ fileStem ] = getTemplateData( view );
			baseData[ "views" ][ fileStem ].delete( "content" );
		}

	}

	function getTemplateData( required string fname ){
		var payload  = {};
		var yaml     = "";
		var body     = "";
		var isBXM    = fname.findNoCase( ".bxm" ) ? true : false;
		var openFile = fileOpen( fname, "read" );
		var lines    = [];

		try {
			while ( !fileIsEOF( openFile ) ) {
				arrayAppend( lines, rTrim( fileReadLine( openFile ) ) );
			}
		} catch ( any e ) {
			rethrow;
		} finally {
			fileClose( openFile );
		}
		// front matter should be at the start of the file
		var fms = !isBXM ? lines.find( "---" ) : lines.find( "<!---" ); // front matter start
		if ( fms == 1 ) {
			var fme = !isBXM ? lines.findAll( "---" )[ 2 ] : lines.findAll( "--->" )[ 1 ]; // front matter end
			lines.each( ( line, index ) => {
				if ( index > 1 && index < fme ) yaml &= lines[ index ] & char( 10 );
				if ( index > fme ) body &= lines[ index ] & char( 10 );
			} );
			if ( yaml.len() ) payload.append( yamlDeserialize( trim( yaml ) ) );
		} else {
			body = arrayToList( lines, char( 10 ) );
		}
		payload[ "content" ] = isBXM ? body : markdown( body );
		return payload;
	}

	/**
	 * Builds the PRC scope for a given template
	 *
	 * @template full path to the template to read
	 */
	function processTemplate( template ){
		var prc = {
			"build_start"            : "",
			"fileSlug"               : getFileFromPath( template ).listFirst( "." ),
			"inFile"                 : template,
			"outFile"                : "",
			"title"                  : "",
			"description"            : "",
			"published"              : true,
			"date"                   : dateTimeFormat( getFileInfo( template ).lastModified, "yyyy-mm-dd HH:nn" ),
			"content"                : "",
			"type"                   : "page",
			"layout"                 : "main",
			"view"                   : "",
			"permalink"              : "",
			"fileExt"                : "html",
			"excludeFromCollections" : false
		};

		// Try reading the front matter from the template
		prc.append( getTemplateData( template ) );

		// merge in layout/view metadata. skip if it overwrites an existing value
		if ( baseData.layouts.keyExists( prc.layout ) ) {
			prc.append( duplicate( baseData.layouts[ prc.layout ] ), false );
		}

		if ( baseData.views.keyExists( prc.type ) && !len( prc.view ) ) {
			prc.append( duplicate( baseData.views[ prc.type ] ), false );
		} else if ( baseData.views.keyExists( prc.view ) && len( prc.view ) ) {
			// `view` overrides `type`, if it exists
			prc.append( duplicate( baseData.views[ prc.view ] ), false );
		}

		// if the template is `published` process it
		if ( isBoolean( prc.published ) && prc.published ) {
			getOutfile( prc );

			// process permalinks
			// todo: clean up
			if ( len( prc.permalink ) ) {
				// permalink was specified, break it apart
				prc.outFile = cwd & "_site" & prc.permalink;

				var temp = prc.permalink.listToArray( "/" ).reverse();
				var slug = temp[ 1 ].listFirst( "." );
				var ext  = temp[ 1 ].listRest( "." );

				prc.permalink = "/" & temp.reverse().toList( "/" );
				prc.fileExt   = len( ext ) ? ext : "html";
			} else {
				// try to calculate the permalink based on the template
				getPermalink( prc );
			}

			// set the view according to type if view is not populated
			if ( !prc.view.len() && prc.type.len() ) {
				prc.view = prc.type;
			}

			// add this template to `collections.all`
			templates.append( prc );
		}
	}

	/**
	 * Calculate the output filename
	 *
	 * @prc request context for the page
	 */
	function getOutfile( required struct prc ){
		var outDir  = "";
		var outFile = "";
		var temp    = "";

		if ( prc.type == "post" ) {
			outFile   = prc.inFile.replace( cwd, "" );
			temp      = outFile.listToArray( "/" ).reverse();
			temp[ 1 ] = ( prc.keyExists( "slug" ) ? prc.slug : prc.fileSlug ) & "." & prc.fileExt;
			outFile   = cwd & "_site/" & temp.reverse().toList( "/" );
		} else {
			if ( len( prc.permalink ) ) {
				outFile  = cwd & "_site" & prc.permalink;
				// calculate the file extension
				var stem = listLast( prc.permalink, "/" );
				if ( stem.find( "." ) ) {
					prc.fileExt = listLast( "." );
				} else {
					// a file exension wasn't specified
					prc.fileExt = "";
				}
			} else {
				outFile = getFileFromPath( prc.inFile ).listFirst( "." );
				outDir  = getDirectoryFromPath( prc.inFile ).replace( cwd, "/" );
				outFile = cwd & "_site" & outDir & outFile & "." & prc.fileExt;
			}
		}
		prc.outfile = outFile;
	}

	/**
	 * Calculate permalink
	 *
	 * @prc request context for the page
	 */
	function getPermalink( required struct prc ){
		// Remove _site/ prefix and split path
		var relPath = prc.outFile.replace( cwd & "_site/", "" );
		var parts = relPath.listToArray( "/" );
		// Process last part (filename)
		var lastIdx = parts.len();
		if ( lastIdx > 0 ) {
			if ( prc.fileExt == "html" ) parts[ lastIdx ] = listFirst( parts[ lastIdx ], "." );
			if ( parts[ lastIdx ] == "index" ) parts[ lastIdx ] = "";
		}
		// Remove empty trailing part if present
		if ( parts.len() > 0 && parts[ parts.len() ] == "" ) parts.deleteAt( parts.len() );
		prc.permalink = "/" & parts.toList( "/" );
	}

	/**
	 * returns rendered html for a template and view
	 *
	 * @prc request context for the current page
	 */
	function renderTemplate( prc ){
		var renderedHtml = "";
		var template     = "";


		try {
			// template is CF markup
			if ( prc.inFile.findNoCase( ".bxm" ) ) {
				if ( process.hasIncludes && process.views.find( prc.view ) && prc.layout != "none" ) {
					// render the cfml in the template first
					template =  prc.inFile ;

					bx:savecontent variable="prc.content" {
						include template;
					}

					// overlay the view
					template = cwd & "_includes/" & prc.view & ".bxm";

					bx:savecontent variable="renderedHtml" {
						include template;
					}
				} else {
					// view was not found, just render the template
					template =  prc.inFile ;

					bx:savecontent variable="renderedHtml" {
						include template;
					}
				}
			}

			// template is markdown
			if ( prc.inFile.findNoCase( ".md" ) ) {

				if ( process.hasIncludes && process.views.find( prc.view ) ) {
					template =  cwd & "_includes/" & prc.view & ".bxm";
					bx:savecontent variable="renderedHtml" {
						include template;
					}
				} else {
					renderedHtml = prc.content;
				}
			}


			// skip layout if "none" is specified
			if (
				prc.layout != "none" &&
				process.hasIncludes &&
				process.layouts.find( prc.layout )
			) {
				template =  cwd & "_includes/layouts/" & prc.layout & ".bxm";

				bx:savecontent variable="renderedHtml" {
					include template;
				}
			}

		} catch ( any e ) {
			printLn( "Error rendering template: " & e.message );
		}

		// if ( isXML( trim( toString(renderedHtml) ) ) ) prc.fileExt = "xml";


		return prc.fileExt == "html" ? htmlParse( renderedHtml ) : renderedHtml;
	}

	/**
	 * Generates data for `collections` scope
	 */
	function processCollectionsData(){
		templates.each( ( template ) => {
			if ( !template.excludeFromCollections && !template.keyExists( "pagination" ) ) {
				collections.all.append( template );
				if ( !collections.keyExists( template.type ) && template.type.len() ) collections[ template.type ] = [];

				// do not track the main page if it is paginated data
				if ( template.type.len() && !template.keyExists( "pagination" ) )
					collections[ lCase( template.type ) ].append( template );
			}
		} );

		// Special processing where `type` is post
		if ( collections.keyExists( "post" ) ) {
			// descending date sort
			collections.post.sort( function( e1, e2 ){
				return dateCompare( e2.date, e1.date );
			} );

			// build the taglist
			collections.post.each( ( post ) => {
				for ( var tag in post.tags ) {
					if ( !collections.tags.findNoCase( tag ) ) {
						collections.tags.append( tag );
					}

					var slugifiedTag = slugify( tag.toString() );
					if ( !collections.byTag.keyExists( slugifiedTag ) ) collections.byTag[ slugifiedTag ] = [];
					collections.byTag[ slugifiedTag ].append( post );
				}
			} );

			collections.tags = collections.tags.sort( "text" );
		}
	}

	/**
	 * Write generated content to files
	 */
	function generateStatic(){
		templates.each( ( prc ) => {
			if ( prc.published ) {
				var contents = renderTemplate( prc ).toString();
				directoryCreate(
					getDirectoryFromPath( prc.outFile ),
					true,
					true
				);

				if ( process.verbose ?: false ) {
					print.greyline(
						" [ " & prc.inFile & " ] -> " &
						"/" & replace( prc.outFile, cwd, "", "all" ) &
						"  [" & prc.fileExt & "]"
					);
				} else {
					printLn( "Writing file: /" & replace( prc.outFile, cwd, "", "all" ) );
				}
				fileWrite( prc.outFile, contents );
			}
		} );
	}
}
